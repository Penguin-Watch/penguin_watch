# 13.6. Multistate occupancy models
owls <- read.table("owls.txt", header = TRUE)
str(owls)

# Specify model in BUGS language
sink("model1.txt")
cat("
model  { 

# Priors
p2 ~ dunif(0, 1)
psi ~ dunif(0, 1)
r ~ dunif(0, 1)
for (i in 1:3) {
   beta[i] ~ dgamma(1, 1)   # Induce Dirichlet prior
   p3[i] <- beta[i]/sum(beta[])
   }


# Define state vector
for (s in 1:R){
   phi[s,1] <- 1 - psi            # Prob. of non-occupation
   phi[s,2] <- psi * (1-r)        # Prob. of occupancy without repro
   phi[s,3] <- psi * r            # Prob. of occupancy and repro
   }

# Define observation matrix
# Order of indices: true state, time, observed state
for (t in 1:T){
   p[1,t,1] <- 1
   p[1,t,2] <- 0
   p[1,t,3] <- 0
   p[2,t,1] <- 1-p2
   p[2,t,2] <- p2
   p[2,t,3] <- 0
   p[3,t,1] <- p3[1]
   p[3,t,2] <- p3[2]
   p[3,t,3] <- p3[3]
   }

# State-space likelihood
# State equation: model of true states (z)
for (s in 1:R){
   z[s] ~ dcat(phi[s,])
   }

# Observation equation
for (s in 1:R){
   for (t in 1:T){ 
      y[s,t] ~ dcat(p[z[s],t,])
      } #t
   } #s

# Derived quantities
for (s in 1:R){
   occ1[s] <- equals(z[s], 1)
   occ2[s] <- equals(z[s], 2)
   occ3[s] <- equals(z[s], 3)
   }
n.occ[1] <- sum(occ1[]) # Sites in state 1
n.occ[2] <- sum(occ2[]) # Sites in state 2
n.occ[3] <- sum(occ3[]) # Sites in state 3
}
",fill=TRUE)
sink()

# Bundle data
y <- as.matrix(owls[, 2:6])
y <- y + 1
win.data <- list(y = y, R = dim(y)[1], T = dim(y)[2])

# Initial values
zst <- apply(y, 1, max, na.rm = TRUE)
zst[zst == "-Inf"] <- 1
inits <- function(){list(z = zst)}

# Parameters monitored
params <- c("p2", "p3", "r", "psi", "n.occ") # Might want to add "z"

# MCMC settings
ni <- 2500
nt <- 2
nb <- 500
nc <- 3

# Call WinBUGS from R (BRT <1 min)
out1 <- bugs(win.data, inits, params, "model1.txt", n.chains = nc, 
n.thin = nt, n.iter = ni, n.burnin = nb, debug =TRUE, bugs.directory = bugs.dir, working.directory = getwd())

# Summarize posteriors
print(out1, dig = 2)

# Specifiy model in BUGS language
sink("model2.txt")
cat("
model  { 

# Priors
psi ~ dunif(0, 1)
r ~ dunif(0,1 )

for (t in 1:T){
   p2[t] ~ dunif(0, 1)
   for (i in 1:3) {
      beta[i,t] ~ dgamma(1, 1)   # Induce Dirichlet prior
      p3[i,t] <- beta[i,t]/sum(beta[,t])
      } #i
   } #t

# Define state vector
for (s in 1:R){
   phi[s,1] <- 1 - psi              # Prob. of non-occupation
   phi[s,2] <- psi * (1-r)          # Prob. of occupancy without repro.
   phi[s,3] <- psi * r              # Prob. of occupancy and repro
   }

# Define observation matrix
# Order of indices: true state, time, observed state
for (t in 1:T){    
   p[1,t,1] <- 1
   p[1,t,2] <- 0
   p[1,t,3] <- 0
   p[2,t,1] <- 1-p2[t]
   p[2,t,2] <- p2[t]
   p[2,t,3] <- 0
   p[3,t,1] <- p3[1,t]
   p[3,t,2] <- p3[2,t]
   p[3,t,3] <- p3[3,t]
   }

# State-space likelihood
# State equation: model of true states (z)
for (s in 1:R){
   z[s] ~ dcat(phi[s,])
   }

# Observation equation
for (s in 1:R){
   for (t in 1:T){ 
      y[s,t] ~ dcat(p[z[s],t,])
      } #t
   } #s

# Derived quantities
for (s in 1:R){
   occ1[s] <- equals(z[s], 1)
   occ2[s] <- equals(z[s], 2)
   occ3[s] <- equals(z[s], 3)
   }
n.occ[1] <- sum(occ1[]) # Sites in state 1
n.occ[2] <- sum(occ2[]) # Sites in state 2
n.occ[3] <- sum(occ3[]) # Sites in state 3
}
",fill=TRUE)
sink()

# Call WinBUGS from R (BRT 1 min)
out2 <- bugs(win.data, inits, params, "model2.txt", n.chains = nc, 
n.thin = nt, n.iter = ni, n.burnin = nb, debug =TRUE, bugs.directory = bugs.dir, working.directory = getwd())

# Summarize posteriors
print(out2, dig = 2)

